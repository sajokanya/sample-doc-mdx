---
title: Customization guide
description: Complete guide to customizing Cirrus Sync behavior, including advanced configuration, custom integrations, and extensibility options for developers.
---

# Customization guide

Cirrus Sync provides extensive customization options to tailor the synchronization experience to your specific needs. This guide covers advanced configuration techniques, custom integrations, and extensibility patterns for developers.

## What is a database schema

A database schema is the structural blueprint that defines how data is organized within a database. It specifies the logical configuration of all or part of a relational database, including:

- **Tables and their relationships** - How different data entities connect to each other
- **Column definitions** - What type of data each field can contain
- **Constraints and rules** - Data validation and integrity requirements
- **Indexes** - Performance optimization structures
- **Views and procedures** - Reusable query logic

The schema acts as a contract between the database and applications, ensuring data consistency and providing a clear understanding of the data structure for developers and database administrators.

## Rules for data normalization

Data normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. The normalization process follows specific rules called normal forms:

### First Normal Form (1NF)
- Each table cell contains only atomic (indivisible) values
- Each column contains values of a single type
- Each column has a unique name
- The order of rows and columns doesn't matter

### Second Normal Form (2NF)
- Must satisfy 1NF requirements
- All non-key attributes must be fully functionally dependent on the primary key
- Eliminates partial dependencies on composite primary keys

### Third Normal Form (3NF)
- Must satisfy 2NF requirements
- No transitive dependencies - non-key attributes should not depend on other non-key attributes
- Each non-key attribute must depend directly on the primary key

### Benefits of normalization
- Reduces data redundancy
- Improves data consistency
- Minimizes storage space
- Simplifies data maintenance
- Prevents update anomalies

## Database table types and relationships

### Base tables and reference tables

**Base tables** contain the primary business data and represent core entities in your application:
- Customer information
- Product catalogs
- Order records
- User accounts
- Transaction logs

**Reference tables** (also called lookup tables) store standardized values that other tables reference:
- Country codes
- Status types
- Category classifications
- Configuration settings
- Enumerated values

Reference tables help maintain data consistency and reduce storage by avoiding repeated text values throughout the database.

### Mapping

Database mapping refers to the process of defining relationships between different data entities. This includes:

- **Entity-relationship mapping** - How real-world objects translate to database tables
- **Object-relational mapping (ORM)** - How application objects correspond to database records
- **Data type mapping** - How different systems represent the same data types
- **Schema mapping** - How data structures translate between different database systems

### Table joins

Table joins combine data from multiple tables based on related columns. Common join types include:

**Inner Join**
```sql
SELECT customers.name, orders.total
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
```

**Left Join**
```sql
SELECT customers.name, orders.total
FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id;
```

**Right Join**
```sql
SELECT customers.name, orders.total
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id;
```

**Full Outer Join**
```sql
SELECT customers.name, orders.total
FROM customers
FULL OUTER JOIN orders ON customers.id = orders.customer_id;
```

### Key fields

Key fields are columns that uniquely identify records or establish relationships between tables:

**Primary Key**
- Uniquely identifies each record in a table
- Cannot contain NULL values
- Must be unique across all records
- Typically auto-incrementing integers or UUIDs

**Foreign Key**
- References the primary key of another table
- Establishes relationships between tables
- Enforces referential integrity
- Can contain NULL values (unless specified otherwise)

**Composite Key**
- Combination of multiple columns that together form a unique identifier
- Used when no single column can uniquely identify records

**Candidate Key**
- Any column or combination of columns that could serve as a primary key
- Must be unique and not null

### Star schema

A star schema is a database design pattern commonly used in data warehousing and business intelligence applications. It consists of:

**Fact Table (Center)**
- Contains quantitative data (metrics, measurements)
- Stores foreign keys to dimension tables
- Typically contains large volumes of data
- Examples: sales transactions, website clicks, sensor readings

**Dimension Tables (Points of the Star)**
- Contain descriptive attributes
- Provide context for fact table data
- Typically smaller than fact tables
- Examples: customer details, product information, time periods

**Benefits of Star Schema:**
- Simple and intuitive design
- Optimized for read-heavy operations
- Excellent query performance
- Easy to understand and maintain
- Supports efficient data aggregation

### Isolated tables

Isolated tables are database tables that have no foreign key relationships with other tables in the schema. These tables:

- Stand alone without dependencies
- Often used for configuration data
- May contain temporary or staging data
- Can be system tables for application metadata
- Useful for audit logs or historical data

While isolated tables can be appropriate in certain scenarios, excessive use may indicate poor database design or missed relationship opportunities.

## Database fields and data types

Database fields (columns) store different types of data, each with specific characteristics and use cases:

### Numeric types

**Integer Types**
- `TINYINT` - Small integers (-128 to 127)
- `SMALLINT` - Small integers (-32,768 to 32,767)
- `INT` - Standard integers (-2,147,483,648 to 2,147,483,647)
- `BIGINT` - Large integers (very large range)

**Decimal Types**
- `DECIMAL(p,s)` - Fixed-point numbers with precision and scale
- `NUMERIC(p,s)` - Similar to DECIMAL, exact numeric values
- `FLOAT` - Floating-point numbers (approximate)
- `DOUBLE` - Double-precision floating-point numbers

### String types

**Fixed-Length Strings**
- `CHAR(n)` - Fixed-length character strings
- Always uses the specified number of characters
- Padded with spaces if shorter than defined length

**Variable-Length Strings**
- `VARCHAR(n)` - Variable-length character strings
- Uses only the space needed for actual content
- Maximum length specified by n

**Text Types**
- `TEXT` - Large amounts of text data
- `LONGTEXT` - Very large text fields
- `CLOB` - Character Large Objects

### Date and time types

- `DATE` - Date values (YYYY-MM-DD)
- `TIME` - Time values (HH:MM:SS)
- `DATETIME` - Combined date and time
- `TIMESTAMP` - Date and time with timezone information
- `YEAR` - Year values (2-digit or 4-digit)

### Boolean types

- `BOOLEAN` - True/false values
- `BIT` - Single bit values (0 or 1)
- Often implemented as TINYINT(1) in some databases

### Binary types

- `BINARY(n)` - Fixed-length binary data
- `VARBINARY(n)` - Variable-length binary data
- `BLOB` - Binary Large Objects for files, images, etc.

### JSON and XML types

- `JSON` - JavaScript Object Notation data
- `XML` - Extensible Markup Language data
- Support for structured document storage and querying

### Specialized types

**UUID/GUID**
- Universally Unique Identifiers
- 128-bit values for unique record identification

**Enum**
- Predefined list of allowed values
- Ensures data consistency for categorical data

**Array Types**
- Store multiple values in a single field
- Supported by some modern databases like PostgreSQL

### Field constraints

**NOT NULL**
- Prevents empty values in the field
- Ensures data completeness

**UNIQUE**
- Ensures all values in the field are different
- Prevents duplicate entries

**DEFAULT**
- Provides automatic value when none is specified
- Simplifies data insertion

**CHECK**
- Validates data against custom conditions
- Enforces business rules at the database level

## Best practices for database design

### Choose appropriate data types
- Use the smallest data type that can accommodate your data
- Consider future growth when sizing fields
- Use appropriate precision for numeric data
- Choose between fixed and variable-length strings based on usage patterns

### Implement proper indexing
- Create indexes on frequently queried columns
- Use composite indexes for multi-column queries
- Monitor and maintain index performance
- Avoid over-indexing which can slow down write operations

### Maintain referential integrity
- Use foreign key constraints to enforce relationships
- Implement cascade rules for related data updates
- Design clear primary key strategies
- Consider using UUIDs for distributed systems

### Plan for scalability
- Design schemas that can grow with your application
- Consider partitioning strategies for large tables
- Plan for read replicas and load distribution
- Design with caching strategies in mind

Understanding these database fundamentals provides the foundation for building robust, scalable applications with efficient data management and retrieval capabilities.